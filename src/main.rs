// src/main.rs

mod db;
mod models;
mod schema; // This file is generated by Diesel.
mod handlers;
mod utils;
mod middleware;
mod models;

use axum::{
    extract::{State},
    response::IntoResponse,
    http::StatusCode,
    routing::{get, post, put, delete},
    Router,
    body::Body,
    middleware::from_fn_with_state
};
use crate::handlers::user_handlers::{list_users, create_user, get_user_by_id, update_user, delete_user};
use db::establish_connection_pool;
use std::net::SocketAddr;
use tokio::net::TcpListener;

use middleware::token_validator::auth_middleware;

// Root handler.
pub async fn root() -> impl IntoResponse {
    let welcome_message = r#"

    ╭──────────────────────────────────────────────────────────────╮
    │                                                              │
    │   ╦═╗╦ ╦╔═╗╔╦╗  ╔═╗╔═╗╦    ╔═╗╔═╗╦═╗╦  ╦╦╔═╗╔═╗              │
    │   ╠╦╝║ ║╚═╗ ║   ╠═╣╠═╝║    ╚═╗║╣ ╠╦╝╚╗╔╝║║  ║╣               │
    │   ╩╚═╚═╝╚═╝ ╩   ╩ ╩╩  ╩    ╚═╝╚═╝╩╚═ ╚╝ ╩╚═╝╚═╝              │
    │                                                              │
    │              Welcome to Rust API Service v1.0                │
    │                                                              │
    ├──────────────────────────────────────────────────────────────┤
    │                                                              │
    │  🚀 API ROUTES:                                              │
    │                                                              │
    │  📌 USERS                                                    │
    │     GET    /users          List all users                    │
    │     POST   /users          Create new user                   │
    │     GET    /users/{id}     Get user details                  │
    │     PUT    /users/{id}     Update user                       │
    │     DELETE /users/{id}     Delete user                       │
    │                                                              │
    │                                                              │
    ├──────────────────────────────────────────────────────────────┤
    │                                                              │
    │  🔧 Made with Rust, Axum, and PostgreSQL                     |
    │                                                              │
    │                                                              │
    ╰──────────────────────────────────────────────────────────────╯

    "#;

    (StatusCode::OK, welcome_message)
}



pub async fn protected_root() -> impl IntoResponse {
    let protected_message = r#"I am Protected Here"#;
    (StatusCode::OK, protected_message)
}

#[tokio::main]
async fn main() {

    let secret = "your_secret_key".to_string();

    // Initialize the database connection pool
    let pool = establish_connection_pool();


    let public_routes = Router::new()
        .route("/", get(root));

    let login_routes = Router::new()

        .route("/login", post(handlers::login_handlers::login))
        .route("/register", post(handlers::login_handlers::register));

    // let protected_routes = Router::new()
    //     .route("/users", get(list_users))
    //     .route("/users", post(create_user))
    //     .route("/users/{id}", get(get_user_by_id))
    //     .route("/users/{id}", put(update_user))
    //     .route("/users/{id}", delete(delete_user));

    let protected_routes = Router::new()
        .route("/logout", post(handlers::login_handlers::logout))
        .route("/protected", get(protected_root))
        .layer(from_fn_with_state(secret.clone(), auth_middleware::<Body>));


    // Create router with routes
    let app = Router::new()
        .nest("/api", public_routes)
        .nest("/api", login_routes)
        .nest("/api", protected_routes)
        .with_state(pool);

    // Set up the server address
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    println!("Server running on http://{}", addr);

    // Create a TCP listener
    let listener = TcpListener::bind(addr).await.unwrap();
    println!("Listening on {}", addr);

    // Start serving
    axum::serve(listener, app).await.unwrap();
}
